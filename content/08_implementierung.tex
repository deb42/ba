\section{Umsetzung der Änderungsanforderungen}
Dieses Kapitel stellt die Stellen vor, an denen Änderungen vorgenommen werden mussten und erläutert die Ursachen, auf Grund derer die Änderungen vorgenommen werden mussten. Hierzu wird zu erst in Abschnitt \ref{sec:umsetzungUeberblick} ein Überblick über die notwendigen Änderungen und Erweiterungen gegeben. In den restlichen Abschnitten wird tiefgehender auf die wichtigen Änderungen und Erweiterungen eingegangen. Dabei wird zuerst die Funktionalität erläutert. Zur Verdeutlichung werden anschließend exemplarisch Ausschnitte aus der Implementierung vorgestellt.




\subsection{Überblick über Änderungen}
\label{sec:umsetzungUeberblick}
In diesem Abschnitt wird ein grundlegender Überblick über alle Änderungen gegeben, die in dem Moodlemodul EASy-DSBuilder vorgenommen wurden, um die Funktionalität des Assessments von B-Baum-Datenstrukturen.

Für die Verwendung des EASy-DSbuilders ist eine Initialisierung seitens eines Lehrenden nötig. In der alten Version konnten die in Kapitel \ref{sec:funktionalitaet} beschriebenen Eigenschaften übergeben werden. Es konnte jedoch noch nicht zwischen Datenstrukturen gewählt werden. So wurde in der alten Version als Datenstrukturtyp defaultmäßig \textit{Tree} übergeben. An dieser Stelle musste eine Auswahlmöglichkeit für Datenstrukturen in der Erstellungsmaske des Moduls implementiert werden. Die Auswahlmöglichkeit wurde als Dropdown-Menü umgesetzt, wobei die in der Datei \pfile{dsbaStructureType.php} definierten Konstanten als Datenstrukturtypen zur Auswahl gestellt werden.

Nachdem eine Instanz des EASy-DSBuilders erzeugt wurde, muss dem Modul jedoch zur Durchführung eines Assessments eine Datenstruktur seitens des Daten- strukturverarbeitungs-Webservices bereitgestellt werden. Die zur Kommunikation zwischen Moodlemodul und Webservice verwendete Datenstruktur wird in Abschnitt \ref{sec:datenstruktur} vorgestellt. An der Funktionalität des Datenstrukturverarbeitungs-Webservice sollte nichts geändert werden. Fehler, die während der Entwicklung auftraten, wurden behoben. Zur Endwicklung des Moodlemoduls musste jedoch die Datenstruktur eines B-Baums in Java implementiert werden, damit die Funktionen des Webservices bereitgestellt werden konnten. \textbf{Über die B-Baum Implementierung schreiben?}

Die wichtigen Erweiterungen zur Bereitstellung der Funktionalität eines Assessments von B-Baum-Datenstrukturen wurde im Moodlemodul fronend- und backendseitig implementiert. Hierbei steht frontendseitig die Erweiterung des Grapheneditors im Vordergrund, welche ausführlich im Abschnitt \ref{sec:erweiterungEditor} erläutert wird. Des Weiteren war die Implementierung einer Verarbeitung der Datenstruktur nötig, sodass zwischen der vom Webservice stammenden Datenstruktur und der für den Editor gebrachten Datenstruktur gewandelt werden konnte. Diese Funktionalität wird ausführlicher in Abschnitt \ref{sec:strukturverarbeitung} erläutert. 
Des weiteren wurden noch folgende kleinere Veränderungen vorgenommen. In der Datei \pfile{renderer.php}, in der die Ansicht generiert wird, wurde eine Fallentscheidung für die Anzeige des Grapheneditors implementiert. Dies ist damit begründet, dass der B-Baum-Editor, wie in Kapitel \ref{sec:konzeptGrapheneditor} begründet, zwei übereinander liegende jsdot-Editoren benötigt. Die Überlagerung der zwei Editoren wurde mit \textit{CSS} umgesetzt.
Weiterhin wurde die AJAX-Api angepasst. Die minimale Änderung bestand darin, dass eine weitere Information übergeben wird, auf die der B-Baum-Editor aufbaut. Näheres dazu ist in Abschnitt \ref{sec:editorImplemenierungsdetails} zu finden. 

\subsection{Datenstruktur für die \\Moodlemodul-Webserice-Kommunikation}
\label{sec:datenstruktur}
Die Datenstruktur, die in in der Kommunikation zwischen Moodlemodul und Webservice eingesetzt wird, spielt eine fundamentale Rolle in der Gesamtanwendung EASy-DSBuilder. Diese Datenstruktur muss in einem JSON-kompatiblen Format alle notwendigen Informationen über die zu verarbeitende Baumstruktur beinhalten. Im Falle des B-Baums muss die Datenstruktur als zentrales Element den Knoten mit der jeweiligen Anzahl an Schlüsseln wiedergeben. Des weiteren muss die Datenstruktur noch die Kindsknoten der Wurzelknotens beinhalten, die wiederum richtig positioniert werden müssen. So können die Kindsnoten als linkes oder rechtes Kind des Wurzelknotens positioniert werden. Weiterhin gibt es noch Kindsknoten, die zwischen den einzelnen Schlüsseln des Wurzelknotens positioniert werden (vergl. Kapitel \ref{sec:bbaum}). 

Auf Basis dieser Grundlage wurde zur Abbildung eines B-Baums ein Array als Datenstruktur ausgewählt. Dieser Array ist bei einem B-Baum \textit{T} mit einer Höhe größer eins wie folgt aufgebaut. Erstes Element des Arrays, welches die oberste Wurzel des B-Baums \textit{T} repräsentiert, ist der linke Kindsknoten der Wurzel. Anschließend folgt der erste Schlüssel der Wurzel, dem ein weiterer Kindsknoten nachfolgt. Diese Abfolge aus Schüssel und Kindsknoten erfolgt so lange, bis das Array mit dem rechten Kindsknoten der Wurzel abschließt. Die jeweiligen Kindsknoten sind nach der selben Struktur des Wurzelknotens aufgebaut. Eine mögliche Repräsentation eines B-Baums durch diese Datenstruktur kann wie folgt aussehen:
\begin{quote}
$[[["16","19"],"31",["37","41"]],"50",[["56"],"86",["96"]]]$
\end{quote} 

Die so eben gezeigte Datenstruktur zeigt einen B-Baum der Höhe drei. Der oberste Wurzelknoten enthält den Schüssel $"3"$. Die Wurzel hat das linke Kind $[["16","19"],"31",["37","41"]]$ und das rechte Kind $[["56"],"86",["96"]]$, welche jeweils separat betrachte einzelne B-Bäume darstellen. Diese Beispiel verdeutlicht anschaulich den rekursiven Aufbau dieser Datenstruktur. Abgeschlossenen wird die Struktur durch kinderlose Knoten, wie sie im vorgestellten B-Baum beispielsweise durch den Knoten $["16","19"]$ repräsentiert werden. Diese Datenstruktur steht wiederum in einem weiteren Array mit der Länge zwei an erster Position. An zweiter Position wird die Ordnungszahl \textit{k} (vergl. Kapitel \ref{sec:bbaum}) abgelegt.


\subsection{Datenstrukturverarbeitung backendseitig}
\label{sec:strukturverarbeitung}

Die in diesem Abschnitt vorgestellten Änderungen beziehen sich auf die in Kapitel \ref{sec:dsbuilderbackend} unter Abschnitt \textit{Datenverarbeitung} vorgestellte Funktionalität. Bei der Datei, in der Änderungen vorgenommen wurden handelt es sich um die \pfile{lib/js\_dot\_ convert.php}. In ihr befinden sich in der alten Version des EASy-DSBuilders die Klassen \pfile{jsdot\_graph}, \pfile{jsdot\_ edge}, \pfile{jsdot\_ node} und \pfile{dsbuilder\_binary\_tree}. Die Klasse \pfile{jsdot\_graph} dient als Schnittstelle zum restlichen Modul und verwaltet den jsdot-Graph. Zum Umgang mit übergebenen Datenstrukturen bedient die Klasse sich im Fall von Binärbäumen der Klasse \pfile{dsbuilder\_binary\_tree}. 


\subsection{Grapheneditor}
\label{sec:erweiterungEditor}
Dieses Kapitel erläutert die neu entwickelte Funktionalität des Frontends. Insbesondere heißt das, dass auf die Umsetzung des Grapheneditors für die B-Baumstruktur eingegangen wird. Hierzu wird zu erst die Umsetzung des in Kapitel \ref{sec:konzeptGrapheneditor} vorgestellten Konzepts des Grapheneditors in Kapitel \ref{sec:editorFunktionalitaet} vorgestellt. Anschießend wird in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender auf einzelne, in Kapitel \ref{sec:editorFunktionalitaet} vorgestellten Funktionen eingegangen.
 
\subsubsection{Funktionalität}
\label{sec:editorFunktionalitaet} 
Aus dem im Kapitel \ref{sec:konzeptGrapheneditor} bereits erläuterten Gründen soll der Grapheneditor aus zwei separaten Elementen bestehen. Diese beiden Elemente sind zwei jsdot-Editoren, welche übereinander liegen. Der im Hintergrund liegende Editor ist nicht bearbeitbar und und liefert die B-Baumstruktur, auf der die Schlüssel des B-Baums angeordnet werden können. Die Schlüssel werden von einem im Vordergrund liegendem jsdot-Editor zur Verfügung gestellt und sind verschiebbar. Um eine höhere Interaktivität bereitzustellen entwickelt sich die im Hintergrund liegend Baumstruktur dynamisch. Das bedeutet, dass sobald ein Schlüssel zu der Baumstruktur hinzugefügt wird, sich die Baumstruktur automatisch um neue Knoten vergrößert.  Die Anpassung beinhaltet die Erweiterung des Knotens, in den eingefügt wurde, sowie die Kindsknoten, die der erweiterte Knoten bereitgestellt bekommt. Ebenso reduziert sich die Baumstruktur nach Endnahme eines Schlüssels um die jeweiligen Knoten. Sobald ein Schlüssel auf einen Knoten abgelegt wird, erkennt das System dies und richtet den gesamten Knoten mit dem neu eingefügten Schlüssel in Echtzeit aus. Durch die automatische Neuausrichtung der Schlüssel kann der Studierende erkennen, ob das System seine Eingabe erkannt hat. 

Abbildung \ref{fig:petri} zeigt ein Petri-Netz, welches die Funktionalität der Echtzeitverarbeitung beschreibt. Das Petri-Netz beinhaltet drei Arten von Transaktionen. Zur erste Art von Transaktionen gehören Referenzen auf Funktionen, die eine Kommunikation zwischen dem GUI und dem Nutzer ermöglichen. Es wird hierfür auf die jQuerey-Funktionen \textit{mousemove()}, \textit{mousedown()} und \textit{mouseup} verwiesen. Zur besseren Erkennbarkeit sind auf diese Funktionen verweisenden Referenzen im Petri-Netz kursiv abgebildet. Bei der zweiten Art von Transaktionen handelt es sich um Ergebnisse von Verzweigungen. Die dritte Art von Transaktionen beschreibt umfangreichere Funktionalitäten, welche in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender beschreiben werden.

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=1\textwidth]{graphics/petriNetz.jpg}
  \caption{Petri-Netz des Grapheneditors}
  \label{fig:petri}
\end{figure}

Ausgangspunkt ist die Funktion \textit{b\_tree\_helper()}, welche die Echtzeitverarbeitung initialisiert.  Aus der auf diese Funktion referierenden Transaktion heraus entstehen zwei Stellen, welche auf Eingaben des Nutzers warten. Es handelt sich hierbei um die Funktionen \textit{mousemove()} und \textit{mousedown()}. \textit{Mousemove()} schlägt jedes mal aus, wenn der Mauszeiger über den Editor fährt. Aus der Stelle \textit{Mouse selected} heraus gibt es zwei mögliche Folgezustände. Wurde kein Schlüssel bewegt (\textit{No key moved}) wird der nächste Zustand mit der erneuten Belegung der Stelle \textit{Waiting for mousemove()} erreicht. Für die Transaktion \textit{One key is moved} muss jedoch die Stelle \textit{Key is selected} belegt sein. Für die Belegung dieser Stelle muss zuerst die Transaktion \textit{mousedown()} durchlaufen sein. Anschließend können die Transaktionen \textit{Clicked on no key} und \textit{Clicked on Key} ausgeführt. Der Grund für den direkten Rücksprung zur Stelle \textit{Waiting for mousedown()} über die Transaktion \textit{Clicked on no key} erfolgt gegen Ende des Kapitels. Wurde jedoch auf einen Schlüssel gedrückt (\textit{Clicked on key}), wird im  Anschluss die Verzweigung durchlaufen, die zwischen dem Schlüssel auf (\textit{Key is on node}) oder nicht auf einem Knoten (\textit{Key is not on node}) unterscheidet. Ist der Schlüssel nicht auf einem Knoten, wird direkt die Stelle \textit{Key is selected} markiert. Ist der Schlüssel hingegen auf einem Knoten wird zuerst die Stelle \textit{changeNode is to be set} markiert. Währenddessen wird die Transaktion \textit{Delete key from node and restructure} durchlaufen, sodass die Stelle \textit{Key is selected} schließlich auch über diese Verzweigung markiert wurde.


In folgenden Absatz wird das Teilnetz um die Stellen \textit{changedNode is to be set} und \textit{changedNode} vorgestellt. Bei \textit{changedNode} handelt es sich um eine Variable, die den zuletzt geänderten Schlüssel beinhaltet. Enthält diese Variable einen Wert, dann ist die gleichnamige Stelle im Petri-Netz markiert. Um die Stelle zu markieren können zwei Transaktionen durchlaufen werden. Zum einen gibt es die Transaktion \textit{Initialize changedNode}, zum anderen \textit{Actualize changedNode}, wobei bei dieser \textit{changedNode} bereits markiert sein muss. Die für beide Transaktionen ausgehende Stelle ist \textit{changedNode is to be set}. Die zur Markierung dieser Stelle notwendigen Transaktionen sind \textit{One key is moved} und \textit{Key is on a node}. Dies bedeutet, dass die Variabel \textit{changeNode} gesetzt wird, sobald ein Schlüssel, der auf einem Knoten liegt, angeklickt, bzw. ausgewählt wird. Des weiteren wird die Variable gesetzt, sobald ein ausgewählter Knoten -- siehe Abhängigkeit zwischen \textit{One key is moved} und \textit{Key is selected} -- auf dem Editor bewegt wird.

Eine von der Stelle \textit{Key is selected} nächstmögliche Transaktion ist die Transaktion \textit{mouseup}, welche auf die jQuery-Funktion \textit{mouseup()} referiert. Diese Funktion wird ausgelöst, sobald der Nutzer die Maustaste löst. Das Petri-Netz zeigt, dass die beiden Stellen \textit{changedNode} und \textit{Key is selected} markiert sein müssen, damit die Transaktion \textit{mouseup} durchlaufen werden kann. Insbesondere muss in diesem Fall zwischen der durch die Transaktion \textit{mouseup} repräsentierten Funktionalität und der jQuery-Funkion \textit{mouseup()} differenziert werden. Die jQuery-Funktion \textit{mouseup()} wird ausgelöst, sobald der Nutzer die Maustaste löst, folglich auch, wenn kein Schlüssel ausgewählt ist. Der auftretende Widerspruch, der durch die Forderung des Petri-Netz nach einen gewählten Knoten für die Ausführung der Transaktion auftritt, wird  durch Betrachtung der in der Funktion \textit{mouseup()} steckenden, durch die Transaktion beschriebenen, Funktionalität aufgelöst. Die durch die Transaktion \textit{mouseup} beschriebene Funktionalität enthält die notwendige Bedingung, dass ein veränderter Schlüssel vorhanden sein muss. Wird diese Bedingung nicht erfüllt, wird die Funktion abgebrochen. Auf Basis dieser Argumentation ist die durch die Transaktion \textit{mouseup} beschriebene Funktionalität nur mit dem Vorhandensein einer \textit{changedNode} verfügbar, obwohl die jQuery-Funktion \textit{mousemove()} ausgelöst worden ist. Hiermit ist ebenso das Enden der Transaktion \textit{Clicked on no Key} in der Stelle \textit{Waiting for mousedown()} begründet. Hiernach wird nach dem lösen der Maustaste zwar die jQuery-Funktion \textit{mouseup()} ausgelöst, die aus der Funktion resultierende Funktionalität wird jedoch nicht angesprochen.


\subsubsection{Implementierungsdetails}
\label{sec:editorImplemenierungsdetails}

In diesem Kapitel wird die Umsetzung der in Kapitel \ref{sec:editorFunktionalitaet} beschriebene Funktionalität der Echtzeitverarbeitung des Grapheneditors vorgestellt. Hierfür wird zu erst auf wichtigen Datenstrukturen eingegangen. Anschließend werden die für die Gesamtfunktionalität wichtigen Teilfunktionalitäten vorgestellt. Hierfür wird insbesondere auf die in Kapitel \ref{sec:editorFunktionalitaet} bereits vorgestellten Teilfunktionalitäten eingegangen.

Die zentrale Datenstruktur für die Echtzeitverarbeitung der Schlüsselausrichtung liefert ein mehrdimensionales Array, welches \pfile{nodesPerTier} genannt wurde. Die höchste Arraydimension verwaltet die Schichten des B-Baums. Schicht meint in diesem Zusammenhang alle Knoten einer bestimmten Höhe. So bildet der Wurzelknoten eines B-Baums die erste Schicht in der Arraystruktur auf Position 0, die nächste Schicht wird von den Kindsknoten der Wurzel auf Position 1 eingenommen. Die einzelnen Schichten werden wiederum durch Arrays dargestellt, welche alle Knoten einer Schicht enthalten. Somit handelt es sich bei dem Array \pfile{nodesPerTier} um ein dreidimensionales Array mit Schichten auf der ersten, Knoten auf der zweiten und Schlüsseln auf der dritten Dimension. Eine weitere wichtige Datenstruktur ist das Array \pfile{nodeListBounds}. Diese Datenstruktur enthält die Grenzen, in denen ein Schlüssel als Schlüssel in einem Knoten gilt. Aus dieser Information über die Positionierung eines Schlüssels wird der Positionierungsprozess eines Knotens angestoßen.

Die Funktion \pfile{b\_tree\_helper} ist die Hilfsfunktion, welche eine Echtzeitverarbeitung der Nutzereingabe ermöglicht. 
