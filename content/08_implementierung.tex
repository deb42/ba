\section{Umsetzung der Änderungsanforderungen}
Dieses Kapitel stellt die Stellen vor, an denen Änderungen vorgenommen werden mussten und erläutert die Ursachen, auf Grund derer die Änderungen vorgenommen werden mussten. Hierzu wird zu erst in Abschnitt \ref{sec:umsetzungUeberblick} ein Überblick über die notwendigen Änderungen und Erweiterungen gegeben. In den restlichen Abschnitten wird tiefgehender auf die wichtigen Änderungen und Erweiterungen eingegangen. Dabei wird zuerst die Funktionalität erläutert. Zur Verdeutlichung werden anschließend exemplarisch Ausschnitte aus der Implementierung vorgestellt.




\subsection{Überblick über Änderungen}
\label{sec:umsetzungUeberblick}
In diesem Abschnitt wird ein grundlegender Überblick über alle Änderungen gegeben, die in dem Moodlemodul EASy-DSBuilder vorgenommen wurden, um die Funktionalität des Assessments von B-Baum-Datenstrukturen.

Für die Verwendung des EASy-DSbuilders ist eine Initialisierung seitens eines Lehrenden nötig. In der alten Version konnten die in Kapitel \ref{sec:funktionalitaet} beschriebenen Eigenschaften übergeben werden. Es konnte jedoch noch nicht zwischen Datenstrukturen gewählt werden. So wurde in der alten Version als Datenstrukturtyp defaultmäßig \textit{Tree} übergeben. An dieser Stelle musste eine Auswahlmöglichkeit für Datenstrukturen in der Erstellungsmaske des Moduls implementiert werden. Die Auswahlmöglichkeit wurde als Dropdown-Menü umgesetzt, wobei die in der Datei \pfile{dsbaStructureType.php} definierten Konstanten als Datenstrukturtypen zur Auswahl gestellt werden.

Nachdem eine Instanz des EASy-DSBuilders erzeugt wurde, muss dem Modul jedoch zur Durchführung eines Assessments eine Datenstruktur seitens des Daten- strukturverarbeitungs-Webservices bereitgestellt werden. Die zur Kommunikation zwischen Moodlemodul und Webservice verwendete Datenstruktur wird in Abschnitt \ref{sec:datenstruktur} vorgestellt. An der Funktionalität des Datenstrukturverarbeitungs-Webservice sollte nichts geändert werden. Fehler, die während der Entwicklung auftraten, wurden behoben. Zur Endwicklung des Moodlemoduls musste jedoch die Datenstruktur eines B-Baums in Java implementiert werden, damit die Funktionen des Webservices bereitgestellt werden konnten. \textbf{Über die B-Baum Implementierung schreiben?}

Die wichtigen Erweiterungen zur Bereitstellung der Funktionalität eines Assessments von B-Baum-Datenstrukturen wurde im Moodlemodul fronend- und backendseitig implementiert. Hierbei steht frontendseitig die Erweiterung des Grapheneditors im Vordergrund, welche ausführlich im Abschnitt \ref{sec:erweiterungEditor} erläutert wird. Des Weiteren war die Implementierung einer Verarbeitung der Datenstruktur nötig, sodass zwischen der vom Webservice stammenden Datenstruktur und der für den Editor gebrachten Datenstruktur gewandelt werden konnte. Diese Funktionalität wird ausführlicher in Abschnitt \ref{sec:strukturverarbeitung} erläutert. 
Des weiteren wurden noch folgende kleinere Veränderungen vorgenommen. In der Datei \pfile{renderer.php}, in der die Ansicht generiert wird, wurde eine Fallentscheidung für die Anzeige des Grapheneditors implementiert. Dies ist damit begründet, dass der B-Baum-Editor, wie in Kapitel \ref{sec:konzeptGrapheneditor} begründet, zwei übereinander liegende jsdot-Editoren benötigt. Die Überlagerung der zwei Editoren wurde mit \textit{CSS} umgesetzt.
Weiterhin wurde die AJAX-Api angepasst. Die minimale Änderung bestand darin, dass eine weitere Information übergeben wird, auf die der B-Baum-Editor aufbaut. Näheres dazu ist in Abschnitt \ref{sec:editorImplemenierungsdetails} zu finden. 

\subsection{Datenstruktur für die \\Moodlemodul-Webserice-Kommunikation}
\label{sec:datenstruktur}
Die Datenstruktur, die in in der Kommunikation zwischen Moodlemodul und Webservice eingesetzt wird, spielt eine fundamentale Rolle in der Gesamtanwendung EASy-DSBuilder. Diese Datenstruktur muss in einem JSON-kompatiblen Format alle notwendigen Informationen über die zu verarbeitende Baumstruktur beinhalten. Im Falle des B-Baums muss die Datenstruktur als zentrales Element den Knoten mit der jeweiligen Anzahl an Schlüsseln wiedergeben. Des weiteren muss die Datenstruktur noch die Kindsknoten der Wurzelknotens beinhalten, die wiederum richtig positioniert werden müssen. So können die Kindsnoten als linkes oder rechtes Kind des Wurzelknotens positioniert werden. Weiterhin gibt es noch Kindsknoten, die zwischen den einzelnen Schlüsseln des Wurzelknotens positioniert werden (vergl. Kapitel \ref{sec:bbaum}). 

Auf Basis dieser Grundlage wurde zur Abbildung eines B-Baums ein Array als Datenstruktur ausgewählt. Dieser Array ist bei einem B-Baum \textit{T} mit einer Höhe größer eins wie folgt aufgebaut. Erstes Element des Arrays, welches die oberste Wurzel des B-Baums \textit{T} repräsentiert, ist der linke Kindsknoten der Wurzel. Anschließend folgt der erste Schlüssel der Wurzel, dem ein weiterer Kindsknoten nachfolgt. Diese Abfolge aus Schüssel und Kindsknoten erfolgt so lange, bis das Array mit dem rechten Kindsknoten der Wurzel abschließt. Die jeweiligen Kindsknoten sind nach der selben Struktur des Wurzelknotens aufgebaut. Eine mögliche Repräsentation eines B-Baums durch diese Datenstruktur kann wie folgt aussehen:
\begin{quote}
$[[["16","19"],"31",["37","41"]],"50",[["56"],"86",["96"]]]$
\end{quote} 

Die so eben gezeigte Datenstruktur zeigt einen B-Baum der Höhe drei. Der oberste Wurzelknoten enthält den Schüssel $"3"$. Die Wurzel hat das linke Kind $[["16","19"],"31",["37","41"]]$ und das rechte Kind $[["56"],"86",["96"]]$, welche jeweils separat betrachte einzelne B-Bäume darstellen. Diese Beispiel verdeutlicht anschaulich den rekursiven Aufbau dieser Datenstruktur. Abgeschlossenen wird die Struktur durch kinderlose Knoten, wie sie im vorgestellten B-Baum beispielsweise durch den Knoten $["16","19"]$ repräsentiert werden. Diese Datenstruktur steht wiederum in einem weiteren Array mit der Länge zwei an erster Position. An zweiter Position wird die Ordnungszahl \textit{k} (vergl. Kapitel \ref{sec:bbaum}) abgelegt.


\subsection{Datenstrukturverarbeitung backendseitig}
\label{sec:strukturverarbeitung}

Die in diesem Abschnitt vorgestellten Änderungen beziehen sich auf die in Kapitel \ref{sec:dsbuilderbackend} unter Abschnitt \textit{Datenverarbeitung} vorgestellte Funktionalität. Bei der Datei, in der Änderungen vorgenommen wurden handelt es sich um die \pfile{lib/js\_dot\_ convert.php}. In ihr befinden sich in der alten Version des EASy-DSBuilders die Klassen \pfile{jsdot\_graph}, \pfile{jsdot\_edge}, \pfile{jsdot\_node} und \pfile{dsbuilder\_binary\_tree}. Die Klasse \pfile{jsdot\_graph} dient als Schnittstelle zum restlichen Modul und verwaltet den jsdot-Graph. Zum Umgang mit übergebenen Datenstrukturen bedient die Klasse sich im Fall von Binärbäumen der Klasse \pfile{dsbuilder\_binary\_tree}. Die nun vorgenommene Erweiterung enthält die Implementierung der Klasse \pfile{dsbuilder\_b\_tree}. Diese neu implementierte Klasse orientiert sich stark an der Klasse \pfile{dsbuilder\_ binary\_tree}. Sie stellt die selben Funktionen bereit,  nur dass die Funktionen in der Klasse \pfile{dsbuilder\_b\_tree} dem Umgang mit B-Baum-Datenstrukturen dienen.

Die drei öffentlichen Funktionen der Klasse \pfile{dsbuilder\_b\_tree} sind die statischen Funktionen 
\textit{initialize\_with\_b\_tree\_data\_structure(...)}, \textit{get\_b\_tree\_data\_ structure(...)} und \textit{compare\_sample\_and\_student\_graph(...)}. Hierbei ermöglichen die ersten beiden Funktionen die Umwandlung der Datenstruktur, sodass mit der Datenstruktur in den beiden Anwendungsfällen Grapheneditor und Webservices gearbeitet werden kann. Die dritte Funktion vergleicht zwei Graphen und markiert die sich unterscheidenden Knoten. Sie wird für die Feedbackfunktion genutzt. Im folgenden werden die Funktionen tiefgehender vorgestellt.

Die Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} initialisiert einen neuen \pfile{jsdot\_graph} anhand der in Kapitel \ref{sec:datenstruktur} vorgestellten serialisierten Datenstruktur. Der Funktion können drei Paramieter übergeben werden. Die Übergabe einer serialisierte Datenstruktur ist verpflichtend. Ansonsten kann übergeben werden, wie viel Abstand der Baum im Editor auf der x-Achse zum linken Rand und auf der y-Achse zum oberen Rand haben soll. Standardmäßig werden 50 Pixel für die x-Achse und 25 Pixel für die y-Achse übergeben. Jedoch handelt es sich bei der Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} nur um eine Wrapperfunktion. Die eigentliche Umwandlung einer serialisierten Datenstruktur in einen \pfile{jsdot\_graph} geschieht in der Hilfsfunktion \textit{b\_tree\_initialize\_helper(...)}. Quellcode \ref{code:bTreeInitHelper} zeigt einen Ausschnitt der Hilfsfunktion.
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=Ausschnitt \textit{b\_tree\_initialize\_helper(...)}, frame=single, label=code:bTreeInitHelper]{code/bTreeInitHelper.php}
\end{figure}
Da es sich bei der serialisierten Datenstruktur um eine rekursiv aufgebaute Datenstruktur handelt ist die Verarbeitung dieser Struktur ebenfalls rekursiv aufgebaut. Der Hilfsfunktion wird eine serialisierte B-Baum-Datenstruktur übergeben. Wie in Kapitel \ref{sec:datenstruktur} beschrieben besteht die Datenstruktur einem Array, welches Schlüssel und Kindsknoten-Arrays des Wurzelknotens enthält. Auf Grund dieser Struktur wird jedes Element des Wurzelknoten-Arrays durchlaufen (Z. 4). Hierbei werden die einzelnen Knoten-Arrays des übergebenen B-Baums durch die Variable \pfile{\$json\_row} widergespiegelt. Für jedes Element in dem jeweiligen Array erfolgt eine Fallunterscheidung, in der geprüft wird, ob es sich bei dem jeweiligen Element um ein \textit{String} handelt. Ist das jeweilige Element ein \textit{String} (Z. 5), so muss es sich um einen Schlüssel im Array handeln. In diesem Fall wird ein neues \pfile{jsdot\_node} initialisiert und den Knoten des \pfile{\$jsdot\_graph} übergeben (Z. 6 f.). Es werden hierbei jeweils Name, Schlüssel und Position an den Knoten übergeben. Wie die Position bestimmt wird, wird in Kapitel \ref{sec:positionierung} erläutert. Handelt es sich nicht um einen \textit{String}, so muss es sich um ein Kindsknoten-Array handeln. In diesem Fall ruft die Hilfsfunktion sich selber auf, damit die Kindsknoten-Arrays auf die selbe Weise verarbeitet werden können. Quellcode \ref{code:rekursiverAufrufInitHelper} zeigt den rekursiven Aufruf in seiner Gesamtheit. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=rekursiver Aufruf aus Quellcode \ref{code:bTreeInitHelper} in Z. 10, frame=single, label=code:rekursiverAufrufInitHelper]{code/rekursiverAufrufInitHelper.php}
\end{figure}
Der erste übergebene Parameter ist wieder der in Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} initialisierte \pfile{jsdot\_graph}. Der zweite Parameter ist das Kindsknoten-Array. Die nächsten beiden Parameter beschreiben die Position des Arrays. Als erstes wird die Höhe übergeben, die eine größer als die momentane Höhe ist. Danach wird die Position innerhalb einer Schicht weitergegeben. \pfile{\$index\_node} sagt dabei aus, um den wievielten Kindsknoten es sich handelt. \pfile{\$indes\_array} zeigt die Position des Wurzelknotens innerhalb der Schicht auf. Diese muss noch mit der Ordnungszahl \pfile{\$t} multipliziert werden, damit die richtige Position für den Kindsknoten gefunden wird. Die Summe bildet schließlich die Finale Position. Die restlichen Parameter werden unverändert weitergegeben.
Zum Abbruch der Funktion dienen die kinderlosen Knoten, da in ihnen keine Kindsknoten-Arrays zum weiteren rekursiven Aufruf vorhanden sind.

Die Funktion \textit{get\_b\_tree\_data\_ structure(...)} wandelt wiederum eine \pfile{jsdot\_graph}-Datenstruktur in eine serialisierte Datenstruktur für den Webservice um. Quellcode \ref{code:getBTreeDataStructure} zeigt die gesamte Funktion. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=\textit{get\_b\_tree\_data\_ structure(...)}, frame=single, label=code:getBTreeDataStructure]{code/getBTreeDataStructure.php}
\end{figure}
So wird der \pfile{jsdot\_graph} als erstes in die Form \glqq Knoten pro Schicht\grqq umgewandelt (Z. 2). Da diese Form bereits aus Kapitel \ref{sec:editorImplemenierungsdetails} bekannt ist, und die Umwandlung hier äquivalent verläuft, wird an dieser Stelle nicht weiter darauf eingegangen. Wichtig für diese Funktion ist jedoch noch, dass in ihr die Richtigkeit der Syntax des B-Baums geprüft wird. Es wird geprüft, ob alle Schlüssel Teil des Baums sind, ob alle Knoten die maximale Anzahl an Schlüsseln nicht überschreiten und ob der Baum ausbalanciert ist. Anschließend wird die rekursive Hilfsfunktion \textit{b\_tree\_structure\_helper(...)} aufgerufen, die die eigentliche Umwandlung umsetzt. Die Hilfsfunktion wird mit dem Wurzelknoten des B-Baums initialisiert (\pfile{\$nodesPerArray[0][0]}). Weiterhin wird noch der gesamte B-Baum, die Position des Wurzelknotens und die Ordnungszahl \pfile{\$t} übergeben. Quellcode \ref{code:bTreeStructureHelper} zeigt die Hilfsfunktion. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=\textit{b\_tree\_structure\_helper(...)}, frame=single, label=code:bTreeStructureHelper]{code/bTreeStructureHelper.php}
\end{figure}
In der Funktion wird jeder Schlüssel des übergebenden Knotens (\pfile{\$nodeList}) durchlaufen (Z. 4). Für jedes Element wird zu erst geprüft, ob ein linker Kindsknoten existiert (Z. 5). Ist dies der Fall, ruft die Funktion sich selbst auf, wobei der Kindsknoten als zu bearbeitendes Element übergeben wird (Z. 6). Anschließend wird das Ergebnis dieses rekursiven Aufrufs zum Ergebnis hinzugefügt (Z. 7). Auch jeder Schlüssel wird dem Ergebnis übergeben (Z. 9). Die zweite if-Abfrage (Z. 10) prüft, ob sich um den letzten Schlüssel eines Knotens handelt, und ob dieser einen rechten Kindsknoten hat. Ist dies der Fall, wird für diesen Kindsknoten ein weiterer rekursiver Aufruf initiiert (Z. 11). Als abbrechende Bedingung für die Rekursion dienen die Kinderlosen Knoten.

\subsection{Grapheneditor}
\label{sec:erweiterungEditor}
Dieses Kapitel erläutert die neu entwickelte Funktionalität des Frontends. Insbesondere heißt das, dass auf die Umsetzung des Grapheneditors für die B-Baumstruktur eingegangen wird. Hierzu wird zu erst die Umsetzung des in Kapitel \ref{sec:konzeptGrapheneditor} vorgestellten Konzepts des Grapheneditors in Kapitel \ref{sec:editorFunktionalitaet} vorgestellt. Anschießend wird in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender auf einzelne, in Kapitel \ref{sec:editorFunktionalitaet} vorgestellten Funktionen eingegangen.
 
\subsubsection{Funktionalität}
\label{sec:editorFunktionalitaet} 
Aus dem im Kapitel \ref{sec:konzeptGrapheneditor} bereits erläuterten Gründen soll der Grapheneditor aus zwei separaten Elementen bestehen. Diese beiden Elemente sind zwei jsdot-Editoren, welche übereinander liegen. Der im Hintergrund liegende Editor ist nicht bearbeitbar und und liefert die B-Baumstruktur, auf der die Schlüssel des B-Baums angeordnet werden können. Die Schlüssel werden von einem im Vordergrund liegendem jsdot-Editor zur Verfügung gestellt und sind verschiebbar. Um eine höhere Interaktivität bereitzustellen entwickelt sich die im Hintergrund liegend Baumstruktur dynamisch. Das bedeutet, dass sobald ein Schlüssel zu der Baumstruktur hinzugefügt wird, sich die Baumstruktur automatisch um neue Knoten vergrößert.  Die Anpassung beinhaltet die Erweiterung des Knotens, in den eingefügt wurde, sowie die Kindsknoten, die der erweiterte Knoten bereitgestellt bekommt. Ebenso reduziert sich die Baumstruktur nach Endnahme eines Schlüssels um die jeweiligen Knoten. Sobald ein Schlüssel auf einen Knoten abgelegt wird, erkennt das System dies und richtet den gesamten Knoten mit dem neu eingefügten Schlüssel in Echtzeit aus. Durch die automatische Neuausrichtung der Schlüssel kann der Studierende erkennen, ob das System seine Eingabe erkannt hat. 

Abbildung \ref{fig:petri} zeigt ein Petri-Netz, welches die Funktionalität der Echtzeitverarbeitung beschreibt. Das Petri-Netz beinhaltet drei Arten von Transaktionen. Zur erste Art von Transaktionen gehören Referenzen auf Funktionen, die eine Kommunikation zwischen dem GUI und dem Nutzer ermöglichen. Es wird hierfür auf die jQuerey-Funktionen \textit{mousemove()}, \textit{mousedown()} und \textit{mouseup} verwiesen. Zur besseren Erkennbarkeit sind auf diese Funktionen verweisenden Referenzen im Petri-Netz kursiv abgebildet. Bei der zweiten Art von Transaktionen handelt es sich um Ergebnisse von Verzweigungen. Die dritte Art von Transaktionen beschreibt umfangreichere Funktionalitäten, welche in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender beschreiben werden.

Ausgangspunkt ist die Funktion \textit{b\_tree\_helper()}, welche die Echtzeitverarbeitung initialisiert.  Aus der auf diese Funktion referierenden Transaktion heraus entstehen zwei Stellen, welche auf Eingaben des Nutzers warten. 
\begin{figure}[tbp] 
  \centering
     \includegraphics[width=1\textwidth]{graphics/petriNetz.jpg}
  \caption{Petri-Netz des Grapheneditors}
  \label{fig:petri}
\end{figure}
Es handelt sich hierbei um die Funktionen \textit{mousemove()} und \textit{mousedown()}. \textit{Mousemove()} schlägt jedes mal aus, wenn der Mauszeiger über den Editor fährt. Aus der Stelle \textit{Mouse selected} heraus gibt es zwei mögliche Folgezustände. Wurde kein Schlüssel bewegt (\textit{No key moved}) wird der nächste Zustand mit der erneuten Belegung der Stelle \textit{Waiting for mousemove()} erreicht. Für die Transaktion \textit{One key is moved} muss jedoch die Stelle \textit{Key is selected} belegt sein. Für die Belegung dieser Stelle muss zuerst die Transaktion \textit{mousedown()} durchlaufen sein. Anschließend können die Transaktionen \textit{Clicked on no key} und \textit{Clicked on Key} ausgeführt. Der Grund für den direkten Rücksprung zur Stelle \textit{Waiting for mousedown()} über die Transaktion \textit{Clicked on no key} erfolgt gegen Ende des Kapitels. Wurde jedoch auf einen Schlüssel gedrückt (\textit{Clicked on key}), wird im  Anschluss die Verzweigung durchlaufen, die zwischen dem Schlüssel auf (\textit{Key is on node}) oder nicht auf einem Knoten (\textit{Key is not on node}) unterscheidet. Ist der Schlüssel nicht auf einem Knoten, wird direkt die Stelle \textit{Key is selected} markiert. Ist der Schlüssel hingegen auf einem Knoten wird zuerst die Stelle \textit{changeNode is to be set} markiert. Währenddessen wird die Transaktion \textit{Delete key from node and restructure} durchlaufen, sodass die Stelle \textit{Key is selected} schließlich auch über diese Verzweigung markiert wurde.


In folgenden Absatz wird das Teilnetz um die Stellen \textit{changedNode is to be set} und \textit{changedNode} vorgestellt. Bei \textit{changedNode} handelt es sich um eine Variable, die den zuletzt geänderten Schlüssel beinhaltet. Enthält diese Variable einen Wert, dann ist die gleichnamige Stelle im Petri-Netz markiert. Um die Stelle zu markieren können zwei Transaktionen durchlaufen werden. Zum einen gibt es die Transaktion \textit{Initialize changedNode}, zum anderen \textit{Actualize changedNode}, wobei bei dieser \textit{changedNode} bereits markiert sein muss. Die für beide Transaktionen ausgehende Stelle ist \textit{changedNode is to be set}. Die zur Markierung dieser Stelle notwendigen Transaktionen sind \textit{One key is moved} und \textit{Key is on a node}. Dies bedeutet, dass die Variabel \textit{changeNode} gesetzt wird, sobald ein Schlüssel, der auf einem Knoten liegt, angeklickt, bzw. ausgewählt wird. Des weiteren wird die Variable gesetzt, sobald ein ausgewählter Knoten -- siehe Abhängigkeit zwischen \textit{One key is moved} und \textit{Key is selected} -- auf dem Editor bewegt wird.

Eine von der Stelle \textit{Key is selected} nächstmögliche Transaktion ist die Transaktion \textit{mouseup}, welche auf die jQuery-Funktion \textit{mouseup()} referiert. Diese Funktion wird ausgelöst, sobald der Nutzer die Maustaste löst. Das Petri-Netz zeigt, dass die beiden Stellen \textit{changedNode} und \textit{Key is selected} markiert sein müssen, damit die Transaktion \textit{mouseup} durchlaufen werden kann. Insbesondere muss in diesem Fall zwischen der durch die Transaktion \textit{mouseup} repräsentierten Funktionalität und der jQuery-Funkion \textit{mouseup()} differenziert werden. Die jQuery-Funktion \textit{mouseup()} wird ausgelöst, sobald der Nutzer die Maustaste löst, folglich auch, wenn kein Schlüssel ausgewählt ist. Der auftretende Widerspruch, der durch die Forderung des Petri-Netz nach einen gewählten Knoten für die Ausführung der Transaktion auftritt, wird  durch Betrachtung der in der Funktion \textit{mouseup()} steckenden, durch die Transaktion beschriebenen, Funktionalität aufgelöst. Die durch die Transaktion \textit{mouseup} beschriebene Funktionalität enthält die notwendige Bedingung, dass ein veränderter Schlüssel vorhanden sein muss. Wird diese Bedingung nicht erfüllt, wird die Funktion abgebrochen. Auf Basis dieser Argumentation ist die durch die Transaktion \textit{mouseup} beschriebene Funktionalität nur mit dem Vorhandensein einer \textit{changedNode} verfügbar, obwohl die jQuery-Funktion \textit{mousemove()} ausgelöst worden ist. Hiermit ist ebenso das Enden der Transaktion \textit{Clicked on no Key} in der Stelle \textit{Waiting for mousedown()} begründet. Hiernach wird nach dem lösen der Maustaste zwar die jQuery-Funktion \textit{mouseup()} ausgelöst, die aus der Funktion resultierende Funktionalität wird jedoch nicht angesprochen.




\subsubsection{Implementierungsdetails}
\label{sec:editorImplemenierungsdetails}

In diesem Kapitel wird die Umsetzung der in Kapitel \ref{sec:editorFunktionalitaet} beschriebene Funktionalität der Echtzeitverarbeitung des Grapheneditors vorgestellt. Hierfür wird zuerst auf die wichtigen Datenstrukturen eingegangen. Anschließend werden die für die Gesamtfunktionalität wichtigen Teilfunktionalitäten veranschaulicht. Zu diesem Zweck wird insbesondere auf die bereits in Kapitel \ref{sec:editorFunktionalitaet} vorgestellten Teilfunktionalitäten eingegangen.

Die zentrale Datenstruktur für die Echtzeitverarbeitung der Schlüsselausrichtung liefert das mehrdimensionales Array \pfile{nodesPerTier}. Der Datenstruktur kann man die Knoten einer Schicht entnehmen, wobei die einzelnen Knoten wiederum über ihre jeweiligen Schlüssel verfügen. Alle Knoten einer Schicht meint in diesem Zusammenhang alle Knoten einer bestimmten Höhe. So verwaltet die höchste Arraydimension die Schichten des B-Baums. Insgesamt ist der mehrdimensionale Array so aufgebaut, dass die oberste Schicht des B-Baums auf Position null in dem Array der obersten Dimension abgebildet wird. Die zweite Dimension des Arrays beinhaltet die Knoten einer Schicht. Das Arrays auf Position Null beinhaltet diesbezüglich den Wurzelknoten. Auf Position Eins beinhaltet der Array der ersten Dimension die nächste Schicht, sodass dort ein Array mit den Kindsknoten der Wurzel  abgelegt ist. Die weiteren Positionen enthalten demnach folglich die weiteren Schichten. 
Die einzelnen Knoten werden wiederum auch durch Arrays dargestellt, welche alle Schlüssel eines Knotens enthalten. Somit handelt es sich bei dem Array \pfile{nodesPerTier} um ein dreidimensionales Array mit Schichten auf der ersten, Knoten auf der zweiten und Schlüsseln auf der dritten Dimension. 

Eine weitere wichtige Datenstruktur ist das Array \pfile{nodeListBounds}. Diese Datenstruktur enthält die Grenzen, in denen ein Schlüssel als Schlüssel innerhalb eines Knotens erkannt wird. Wird folglich ein Schüssel auf dem Editor innerhalb dieser Grenzen abgelegt, wird ein Positionierungsprozess angestoßen, in dem die Schlüssel eines Knotens neu positioniert werden. Das Array \pfile{nodeListBounds} ist dem Array \pfile{nodesPerTier} stark nachempfunden. So handelt es sich ebenfalls um ein dreidimensionales Array, wobei auch hier die Schichten auf der ersten und die Knoten auf der zweiten Dimension abgelegt werden. In der dritten Dimension sind jedoch anstatt von Schlüsseln die Grenzen der einzelnen Knoten gespeichert. 


Die Funktion \pfile{b\_tree\_helper} ist die Hilfsfunktion, welche eine Echtzeitverarbeitung der Nutzereingabe ermöglicht. Sie bekommt als Parameter die beiden Graphen, den Vordergrund- und den Hintergrundgraphen, und die Ordnung \textit{t} übergeben.


\subsubsection{Aufbau des B-Baums im Hintergrund}
\label{sec:aufbauBBaumHintergrund}
Dieser Abschnitt erläutert das Prinzip nach dem die B-Baum-Struktur im Hintergrund des Grapheneditors aufgebaut wird. 
