\section{Umsetzung der Änderungsanforderungen}
In dieses Kapitel werden die Stellen vorgestellt, an denen Änderungen vorgenommen wurden und erläutert die Hintergründe, auf Grund derer diese Änderungen vorgenommen werden mussten. Hierzu wird zu erst in Abschnitt \ref{sec:umsetzungUeberblick} ein Überblick über die notwendigen Änderungen und Erweiterungen gegeben. In den restlichen Abschnitten wird tiefgehender auf die wichtigen Änderungen und Erweiterungen eingegangen. Dabei wird zuerst die Funktionalität erläutert. Zur Verdeutlichung werden anschließend exemplarisch Ausschnitte aus der Implementierung vorgestellt.




\subsection{Überblick über Änderungen}
\label{sec:umsetzungUeberblick}
In diesem Abschnitt wird ein grundlegender Überblick über alle Änderungen gegeben, die in dem Moodle-Modul EASy-DSBuilder vorgenommen wurden, um die Anforderungen aus Kapitel \ref{sec:neuanforderungen} über Funktionalität des Assessments von B-Baum-Datenstrukturen umzusetzen.

Für die Verwendung des EASy-DSBuilders ist eine Initialisierung seitens eines Lehrenden nötig. In der alten Version konnten die in Kapitel \ref{sec:funktionalitaet} beschriebenen Eigenschaften übergeben werden. Es kann jedoch nicht zwischen Datenstrukturen gewählt werden. So wird in der alten Version als Datenstrukturtyp defaultmäßig \textit{Tree} übergeben. An dieser Stelle ist eine Auswahlmöglichkeit für Datenstrukturen in der Erstellungsmaske des Moduls implementiert worden. Die Auswahlmöglichkeit ist als Dropdown-Menü umgesetzt worden, wobei die in der Datei \pfile{dsbaStructureType.php} definierten Konstanten als Datenstrukturtypen zur Auswahl gestellt sind.

Nachdem eine Instanz des EASy-DSBuilders erzeugt ist, muss dem Modul jedoch zur Durchführung eines Assessments eine Datenstruktur seitens des Daten- strukturverarbeitungs-Webservices bereitgestellt werden. Die zur Kommunikation zwischen Moodle-Modul und Webservice verwendete Datenstruktur wird in Abschnitt \ref{sec:datenstruktur} vorgestellt. An der Funktionalität des Datenstrukturverarbeitungs-Webservices ist nichts geändert worden. Fehler, die während der Entwicklung auftraten, wurden behoben. Zur Endwicklung des Moodle-Moduls musste jedoch die Datenstruktur eines B-Baums in Java implementiert werden, damit die Funktionen des Webservices bereitgestellt werden konnten.

Die wichtigen Erweiterungen zur Bereitstellung der Funktionalität eines Assessments von B-Baum-Datenstrukturen wurde im Moodle-Modul fronend- und backendseitig implementiert. Hierbei steht frontendseitig die Erweiterung des Grapheneditors im Vordergrund, welche ausführlich im Abschnitt \ref{sec:erweiterungEditor} erläutert wird. Des Weiteren war die Implementierung einer Verarbeitung der Datenstruktur im Backend nötig, sodass zwischen der vom Webservice stammenden Datenstruktur und der für den Editor gebrauchten Datenstruktur gewandelt werden konnte. Diese Funktionalität wird ausführlicher in Abschnitt \ref{sec:strukturverarbeitung} erläutert. 
Des Weiteren wurden noch folgende Veränderungen vorgenommen. In der Datei \pfile{renderer.php}, in der die Ansicht generiert wird, wurde eine Fallentscheidung für die Anzeige des Grapheneditors implementiert. Dies ist damit begründet, dass der B-Baum-Editor, wie in Kapitel \ref{sec:konzeptGrapheneditor} begründet, zwei übereinander liegende jsdot-Editoren benötigt. Die Überlagerung der beiden Editoren wurde mit \textit{CSS} umgesetzt.
Weiterhin wurde die AJAX-Api angepasst. Die minimale Änderung bestand darin, dass eine weitere Information übergeben wird, auf die der B-Baum-Editor aufbaut.

\subsection{Datenstruktur für die \\Moodle-Modul-Webservice-Kommunikation}
\label{sec:datenstruktur}
Die Datenstruktur, die in in der Kommunikation zwischen Moodle-Modul und Webservice eingesetzt wird, spielt eine fundamentale Rolle in der Gesamtanwendung EASy-DSBuilder. Diese Datenstruktur muss in einem JSON-kompatiblen Format alle notwendigen Informationen über die zu verarbeitende Baumstruktur beinhalten. Im Falle des B-Baums muss die Datenstruktur als zentrales Element den Knoten mit der jeweiligen Anzahl an Schlüsseln wiedergeben. Des Weiteren muss die Datenstruktur noch die Kindsknoten der innere Knoten beinhalten, die wiederum richtig positioniert werden müssen. So können die Kindsnoten als linkes oder rechtes Kind des inneren Knotens positioniert werden. Weiterhin gibt es noch Kindsknoten, die zwischen den einzelnen Schlüsseln des Wurzelknotens positioniert werden (vgl. Kapitel \ref{sec:bbaum}). 

Auf Basis dieser Grundlage wurde zur Abbildung eines B-Baums eine mehrdimensionale Arraystruktur als Datenstruktur ausgewählt. Diese Arraystruktur ist bei einem B-Baum \textit{T} mit einer Höhe größer eins wie folgt aufgebaut. Die erste Dimension der Arraystruktur spiegelt die Wurzel des B-Baums \textit{T} wieder. Erstes Element des Arrays ist der linke Kindsknoten der Wurzel. Anschließend folgt der erste Schlüssel der Wurzel, dem ein weiterer Kindsknoten nachfolgt. Diese Abfolge aus Schüssel und Kindsknoten erfolgt so lange, bis das Array mit dem rechten Kindsknoten der Wurzel abschließt. Die jeweiligen Kindsknoten sind nach derselben Struktur des Wurzelknotens aufgebaut. Eine mögliche Repräsentation eines B-Baums durch diese Datenstruktur kann wie folgt aussehen:
\begin{quote}
$[[["16","19"],"31",["37","41"]],"50",[["56"],"86",["96"]]]$
\end{quote} 

Die so eben gezeigte Datenstruktur zeigt einen B-Baum der Höhe drei. Der oberste Wurzelknoten enthält den Schüssel $"3"$. Die Wurzel hat das linke Kind $[["16","19"],"31",["37","41"]]$ und das rechte Kind $[["56"],"86",["96"]]$, welche jeweils separat betrachte einzelne B-Bäume darstellen. Diese Beispiel verdeutlicht anschaulich den rekursiven Aufbau dieser Datenstruktur. Abgeschlossenen wird die Struktur durch kinderlose Knoten, wie sie im vorgestellten B-Baum beispielsweise durch den Knoten $["16","19"]$ repräsentiert werden. Diese Datenstruktur steht wiederum in einem weiteren Array mit der Länge zwei an erster Position. An zweiter Position wird die Ordnungszahl \textit{m} (vgl. Kapitel \ref{sec:bbaum}) abgelegt.

\subsection{Grapheneditor}
\label{sec:erweiterungEditor}
Im Folgenden wird die neu entwickelte Funktionalität des Frontends erläutert. Insbesondere bedeutet dies, dass auf die Umsetzung des Grapheneditors für die B-Baumstruktur eingegangen wird. Hierzu wird zuerst die Umsetzung des in Kapitel \ref{sec:konzeptGrapheneditor} vorgestellten Konzepts des Grapheneditors in Kapitel \ref{sec:editorFunktionalitaet} vorgestellt. Anschließend wird in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender auf einzelne, in Kapitel \ref{sec:editorFunktionalitaet} vorgestellten Funktionen eingegangen.

\subsubsection{Positionierung der B-Baum-Elemente}
\label{sec:positionierungElementeBBaum}
Dieser Abschnitt erläutert das Prinzip, nach dem die B-Baum-Elemente positioniert werden. Die zentrale Datenstruktur für die Positionierung der Elemente liefert das mehrdimensionales Array \pfile{nodesPerTier}. Aus der obersten Dimension des Arrays kann man die Knoten einer Schicht entnehmen, wobei die einzelnen Knoten wiederum über ihre jeweiligen Schlüssel verfügen. Alle Knoten einer Schicht meint in diesem Zusammenhang alle Knoten einer bestimmten Höhe. Der Einfachheit halber werden den Dimensionen des Arrays Buchstaben zugeordnet. Der ersten Dimension, welche die Schichten enthält, wird \textit{i} zugeordnet. Der zweiten Dimension, welche die Knoten enthält, wird \textit{j} zugeordnet. Der dritten Dimension, welche die Schlüssel enthält, wird \textit{k} zugeordnet. Somit kann über das Array \pfile{nodesPerTier[i][j][k]} auf den \textit{k}-ten Schüssel des \textit{j}-ten Knotens in der \textit{i}-ten Schicht zugegriffen werden. Über die Variablen \textit{i}, \textit{j} und \textit{k} können Schlüssel somit eindeutig identifiziert werden. Wie die Schlüssel in die Datenstruktur \pfile{nodesPerTier[i][j][k]} eingeordnet werden, wird in Kapitel \ref{sec:editorImplemenierungsdetails} erläutert.

Über das Array \pfile{nodesPerTier} erfolgt die Positionierung der einzelnen Schlüssel. Über diese Struktur wird jedem Schlüssel eine bestimmte Position auf dem Editor zugeordnet. Die Position auf der y-Achse errechnet sich über die Formel $50 * i + 25$. Die Höhendifferenz pro Schicht beträgt somit 50 Pixel. Weiterhin erhält der B-Baum einen Abstand zum oberen Rand des Editors von 25 Pixeln. Die Position auf der x-Achse berechnet sich über die Formel $spacing\_x + x\_start + (place\_per\_array * j) + (k * 30)$. Die Variable $spacing\_x $ beschreibt den Abstand, den der B-Baum vom linken Rand des Editors hat. Der Betrag liegt bei 50 Pixeln, sodass der neu einzufügende Knoten in diesem Bereich platziert werden kann. Die Variable $x\_start$ beschriebt den Betrag, um welchen die Knoten je Schicht eingerückt werden, damit der B-Baum eine gleichmäßige Struktur erhält. Über den Ausdruck $place\_per\_array * j$ werden die Knoten auf ihre jeweilige Position gebracht. $Place\_per\_array$ beschreibt den Platz, den ein Knoten zur Verfügung hat. Dieser Platz hängt von der Höhe des Knotens ab. Über den Index \textit{j} wird der Knoten um den richtigen Betrag verschoben. Zuletzt wird noch der Schlüssel durch den Ausdruck $(k * 30)$ richtig positioniert. Es werden jedem Schlüssel hierbei 30 Pixel zur Verfügung gestellt.

Abbildung \ref{fig:bTreeEditor} zeigt eine B-Baum-Struktur im Editor. Die kreisförmigen Elemente stellen die Schlüssel dar. Die rechteckigen Elemente repräsentieren in ihrer Gesamtheit die Knoten des Baums, wobei sie einzeln die Stellen widerspiegeln, auf denen Schlüssel abgelegt werden können.  
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=1\textwidth]{graphics/editorBaum.jpg}
  \caption{B-Baum-Struktur im Editor}
  \label{fig:bTreeEditor}
\end{figure} 
Dem Studierenden steht es frei die Schlüssel zu bewegen. Bewegt der Studierende einen Schlüssel von einem Knotenelement, so reduziert sich die Baumstruktur. Legt der Studierende hingegen einen Schlüssel auf einem Knoten ab, so erkennt das System dies und ordnet den Schlüssel automatisch in den Knoten ein. Die Baumstruktur erweitert sich währenddessen. Die Funktionalität der Nutzereingabenverarbeitung wird tiefgehender im folgenden Kapitel \ref{sec:editorFunktionalitaet} erläutert.
 
 
\subsubsection{Funktionalität}
\label{sec:editorFunktionalitaet} 
Aus dem im Kapitel \ref{sec:konzeptGrapheneditor} bereits erläuterten Gründen soll der Grapheneditor aus zwei separaten Elementen bestehen. Diese beiden Elemente sind zwei jsdot-Editoren, welche übereinander liegen. Der im Hintergrund liegende Editor ist nicht bearbeitbar und und liefert die B-Baumstruktur, auf der die Schlüssel des B-Baums angeordnet werden können. Die Schlüssel werden von einem im Vordergrund liegendem jsdot-Editor zur Verfügung gestellt und sind verschiebbar. Um eine höhere Interaktivität bereitzustellen entwickelt sich die im Hintergrund liegend Baumstruktur dynamisch. Das bedeutet, dass sobald ein Schlüssel zu der Baumstruktur hinzugefügt wird, sich die Baumstruktur automatisch um neue Knoten vergrößert.  Die Anpassung beinhaltet die Erweiterung des Knotens, in den eingefügt wurde, sowie die Kindsknoten, die der erweiterte Knoten bereitgestellt bekommt. Ebenso reduziert sich die Baumstruktur nach Entnahme eines Schlüssels um die jeweiligen Knoten. Sobald ein Schlüssel auf einen Knoten abgelegt wird, erkennt das System dies und richtet den gesamten Knoten mit dem neu eingefügten Schlüssel in Echtzeit aus. Durch die automatische Neuausrichtung der Schlüssel kann der Studierende erkennen, ob das System seine Eingabe erkannt hat. 

Abbildung \ref{fig:petri} zeigt ein Petri-Netz, welches die Funktionalität der Echtzeitverarbeitung beschreibt. Das Petri-Netz beinhaltet drei Arten von Transaktionen. Zur erste Art von Transaktionen gehören Referenzen auf Funktionen, die eine Kommunikation zwischen dem GUI und dem Nutzer ermöglichen. Es wird hierfür auf die jQuerey-Funktionen \textit{mousemove()}, \textit{mousedown()} und \textit{mouseup} verwiesen. Zur besseren Erkennbarkeit sind auf diese Funktionen verweisenden Referenzen im Petri-Netz kursiv abgebildet. Bei der zweiten Art von Transaktionen handelt es sich um Ergebnisse von Verzweigungen. Die dritte Art von Transaktionen beschreibt umfangreichere Funktionalitäten, welche in Kapitel \ref{sec:editorImplemenierungsdetails} tiefgehender beschreiben werden.

Ausgangspunkt ist die Funktion \textit{b\_tree\_helper()}, welche die Echtzeitverarbeitung initialisiert.  Aus der auf diese Funktion referierenden Transaktion heraus entstehen zwei Stellen, welche auf Eingaben des Nutzers warten. 
\begin{figure}[tbp] 
  \centering
     \includegraphics[width=1\textwidth]{graphics/petriNetz.jpg}
  \caption{Petri-Netz des Grapheneditors}
  \label{fig:petri}
\end{figure}
Es handelt sich hierbei um die Funktionen \textit{mousemove()} und \textit{mousedown()}. \textit{Mousemove()} wird ausgeführt, wenn der Mauszeiger über den Editor fährt. Aus der Stelle \textit{Mouse selected} heraus gibt es zwei mögliche Folgezustände. Wurde kein Schlüssel bewegt (\textit{No key moved}) wird der nächste Zustand mit der erneuten Belegung der Stelle \textit{Waiting for mousemove()} erreicht. Für die Transaktion \textit{One key is moved} muss jedoch die Stelle \textit{Key is selected} belegt sein. Für die Belegung dieser Stelle muss zuerst die Transaktion \textit{mousedown()} durchlaufen sein. Anschließend können die Transaktionen \textit{Clicked on no key} oder \textit{Clicked on Key} ausgeführt. Eine Erläuterung des Vorgehens für den direkten Rücksprung zur Stelle \textit{Waiting for mousedown()} über die Transaktion \textit{Clicked on no key} erfolgt gegen Ende des Kapitels. Wurde jedoch auf einen Schlüssel des B-Baums gedrückt (\textit{Clicked on key}), wird im  Anschluss die Verzweigung durchlaufen, die zwischen dem Schlüssel auf (\textit{Key is on node}) oder nicht auf einem Knoten (\textit{Key is not on node}) unterscheidet. Liegt der Schlüssel nicht über einem Knoten, wird direkt die Stelle \textit{Key is selected} markiert. Liegt der Schlüssel hingegen über einem Knoten wird zuerst die Stelle \textit{changeNode is to be set} markiert. Währenddessen wird die Transaktion \textit{Delete key from node and restructure} durchlaufen, sodass die Stelle \textit{Key is selected} schließlich auch über diese Verzweigung markiert wird.


In folgenden Absatz wird das Teilnetz um die Stellen \textit{changedNode is to be set} und \textit{changedNode} vorgestellt. Bei \textit{changedNode} handelt es sich um eine Variable, die den zuletzt geänderten Schlüssel beinhaltet. Enthält diese Variable einen Wert, dann ist die gleichnamige Stelle im Petri-Netz markiert. Um die Stelle zu markieren können zwei Transaktionen durchlaufen werden. Zum einen gibt es die Transaktion \textit{Initialize changedNode}, zum anderen die Transaktion \textit{Actualize changedNode}, wobei bei dieser \textit{changedNode} bereits markiert sein muss. Die für beide Transaktionen ausgehende Stelle ist \textit{changedNode is to be set}. Die zur Markierung dieser Stelle notwendigen Transaktionen sind \textit{One key is moved} und \textit{Key is on a node}. Dies bedeutet, dass die Variabel \textit{changeNode} gesetzt wird, sobald ein Schlüssel, der auf einem Knoten liegt, angeklickt, bzw. ausgewählt wird. Des weiteren wird die Variable gesetzt, sobald ein ausgewählter Knoten -- siehe Abhängigkeit zwischen \textit{One key is moved} und \textit{Key is selected} -- auf dem Editor bewegt wird.

Eine von der Stelle \textit{Key is selected} nächstmögliche Transaktion ist die Transaktion \textit{mouseup()}, welche auf die jQuery-Funktion \textit{mouseup()} referiert. Diese Funktion wird ausgelöst, sobald der Nutzer die Maustaste löst. Das Petri-Netz zeigt, dass die beiden Stellen \textit{changedNode} und \textit{Key is selected} markiert sein müssen, damit die Transaktion \textit{mouseup} durchlaufen werden kann. Insbesondere muss in diesem Fall zwischen der durch die Transaktion \textit{mouseup()} repräsentierten Funktionalität und der jQuery-Funkion \textit{mouseup()} differenziert werden. Die jQuery-Funktion \textit{mouseup()} wird ausgelöst, sobald der Nutzer die Maustaste löst, folglich auch, wenn kein Schlüssel ausgewählt ist. Für die Transaktion \textit{mouseup()} müssen jedoch die eben beschriebenen Stellten markiert sein. Der auftretende Widerspruch, der durch die Forderung des Petri-Netzes nach einer Belegung dieser Stellen für die Ausführung der Transaktion auftritt, wird  durch Betrachtung der in der Funktion \textit{mouseup()} steckenden, durch die Transaktion beschriebenen, Funktionalität aufgelöst. Die der Transaktion \textit{mouseup()} folgende Funktionalität enthält die notwendige Bedingung, dass ein veränderter Schlüssel vorhanden sein muss. Wird diese Bedingung nicht erfüllt, wird die Funktion abgebrochen. Auf Basis dieser Argumentation ist der Transaktion \textit{mouseup()} folgende Funktionalität nur mit dem Vorhandensein einer \textit{changedNode} verfügbar, obwohl die jQuery-Funktion \textit{mousemove()} ausgelöst worden ist. Hiermit ist ebenso das Enden der Transaktion \textit{Clicked on no Key} in der Stelle \textit{Waiting for mousedown()} begründet. Hiernach wird nach dem Lösen der Maustaste zwar die jQuery-Funktion \textit{mouseup()} ausgelöst, die aus der Funktion resultierende Funktionalität wird jedoch nicht angesprochen. Der Transaktion \textit{mouseup()} folgt eine Fallunterscheidung. Ist der Schlüssel auf einem Knoten abgelegt worden, so wird er zu diesem Knoten hinzugefügt und der Knoten wird neu strukturiert. Anschließend wird die Marke zu der Stelle \textit{Waiting for mousedown()} geleitet. Ist der Schlüssel nicht auf einem Knoten abgelegt worden, so wird die Marke direkt an die Stelle \textit{Waiting for mousedown()} geleitet. Somit befindet der Editor sich wieder im Ausgangszustand.




\subsubsection{Implementierungsdetails}
\label{sec:editorImplemenierungsdetails}

In diesem Kapitel wird die Umsetzung der in Kapitel \ref{sec:editorFunktionalitaet} beschriebene Funktionalität der Echtzeitverarbeitung des Grapheneditors vorgestellt. Hierfür wird zuerst auf die wichtigen Datenstrukturen eingegangen. Anschließend werden die für die Gesamtfunktionalität wichtigen Teilfunktionalitäten veranschaulicht. Zu diesem Zweck wird insbesondere auf die bereits in Kapitel \ref{sec:editorFunktionalitaet} vorgestellten Teilfunktionalitäten eingegangen. Insbesondere wird vorgestellt, wie das System erkennt, dass ein Knoten ausgewählt, bewegt und wieder abgelegt wird. Außerdem wird gezeigt, wie die Verwaltung der Schlüssel in einem Knoten funktioniert, wie also erkannt wird, ob der Studierende einen Schlüssel zu einem Knoten hinzugefügt hat.

Neben der Datenstruktur \pfile{nodesPerTier} (vgl. \ref{sec:positionierungElementeBBaum}) ist eine weitere wichtige Datenstruktur das Array \pfile{nodeListBounds}. Diese Datenstruktur enthält die Grenzen der x-Achse, in denen ein Schlüssel als Schlüssel innerhalb eines Knotens erkannt wird. Das Array \pfile{nodeListBounds} ist dem Array \pfile{nodesPerTier} stark nachempfunden. So handelt es sich ebenfalls um ein dreidimensionales Array, wobei auch hier die Schichten auf der ersten und die Knoten auf der zweiten Dimension abgelegt werden. In der dritten Dimension sind jedoch anstatt von Schlüsseln die Grenzen der einzelnen Knoten gespeichert. Quellcode \ref{code:getTierAndNode} zeigt, wie die übergebene Position einem Schlüssel die aus Kapitel \ref{sec:positionierungElementeBBaum} bekannten Variablen \textit{i}, \textit{j} und \textit{k} eindeutig zugeordnet werden kann. 
\begin{figure}[htbp] 
\lstinputlisting[language=JavaScript, caption=Ausschnitt \textit{b\_tree\_initialize\_helper(...)}, frame=single, label=code:getTierAndNode]{code/getTierAndNode.js}
\end{figure}
In der Funktion \pfile{getTierAndList} wird jede Schicht durchlaufen (Z. 2) und geprüft, die übergebene Position einer Schicht zugeordnet werden kann (Z. 3). Ist dies der Fall, werden die einzelnen Knoten einer Schicht durchlaufen (Z. 4). Nun wird geprüft, ob die übergebene Position einem Knoten zuordenbar ist (Z. 5). Hierfür wird sich der zuvor vorgestellten Datenstruktur \pfile{nodeListBounds} bedient. Ebendies geschieht anschließend für die Zuordenbarkeit der Position zu einem Schlüssel. Ist eine Zuordnung bestimmbar, so wird diese zurückgegeben. Nach diesem Prinzip funktioniert auch die Einordnung von Schlüsseln in die Datenstruktur \pfile{nodesPerTier}.

Eine weitere wichtige Funktion ist die Neustrukturierung eines Knotens. Quellcode \ref{code:restructureNode} zeigt die Neustrukturierung nach dem Hinzufügen eines weiteren Schlüssels. 
\begin{figure}[htbp] 
\lstinputlisting[language=JavaScript, caption=Ausschnitt \textit{b\_tree\_initialize\_helper(...)}, frame=single, label=code:restructureNode]{code/restructureNode.js}
\end{figure}
Zu erst wird der geänderte Schlüssel dem entsprechenden Knoten der Datenstruktur \pfile{nodesPerTier} übergeben (Z. 1). Die Position des Knotens im Array wird über die so eben vorgestellte Methode \pfile{getTierAndList} bestimmt. Anschließend werden die Schlüssel im Knoten der x-Position nach sortiert (Z. 2 ff.). Abschließend wird den sortierten Schlüsseln nach der in Kapitel \ref{sec:positionierungElementeBBaum} vorgestellten Methode ihre neue Position auf der x-Achse zugewiesen.


\subsection{Datenstrukturverarbeitung backendseitig}
\label{sec:strukturverarbeitung}

Die in diesem Abschnitt vorgestellten Änderungen beziehen sich auf die in Kapitel \ref{sec:dsbuilderbackend} unter Abschnitt \textit{Datenverarbeitung} vorgestellte Funktionalität. Bei der Datei, in der Änderungen vorgenommen wurden handelt es sich um die \pfile{lib/js\_dot\_ convert.php}. In ihr befinden sich in der alten Version des EASy-DSBuilders die Klassen \pfile{jsdot\_graph}, \pfile{jsdot\_edge}, \pfile{jsdot\_node} und \pfile{dsbuilder\_binary\_tree}. Die Klasse \pfile{jsdot\_graph} dient als Schnittstelle zum restlichen Modul und verwaltet den jsdot-Graph. Zum Umgang mit übergebenen Datenstrukturen bedient die Klasse sich im Fall von Binärbäumen der Klasse \pfile{dsbuilder\_binary\_tree}. Die nun vorgenommene Erweiterung enthält die Implementierung der Klasse \pfile{dsbuilder\_b\_tree}. Diese neu implementierte Klasse orientiert sich stark an der Klasse \pfile{dsbuilder\_ binary\_tree}. Sie stellt die selben Funktionen bereit,  nur dass die Funktionen in der Klasse \pfile{dsbuilder\_b\_tree} dem Umgang mit B-Baum-Datenstrukturen dienen.

Die drei öffentlichen Funktionen der Klasse \pfile{dsbuilder\_b\_tree} sind die statischen Funktionen 
\textit{initialize\_with\_b\_tree\_data\_structure(...)}, \textit{get\_b\_tree\_data\_ structure(...)} und \textit{compare\_sample\_and\_student\_graph(...)}. Hierbei ermöglichen die ersten beiden Funktionen die Umwandlung der Datenstruktur, sodass mit der Datenstruktur in den beiden Anwendungsfällen Grapheneditor und Webservices gearbeitet werden kann. Die dritte Funktion vergleicht zwei Graphen und markiert die sich unterscheidenden Knoten. Sie wird für die Feedbackfunktion genutzt. Im folgenden werden die ersten beiden Funktionen tiefgehender vorgestellt.

Die Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} initialisiert einen neuen \pfile{jsdot\_graph} anhand der in Kapitel \ref{sec:datenstruktur} vorgestellten serialisierten Datenstruktur. Der Funktion können drei Parameter übergeben werden. Die Übergabe einer serialisierte Datenstruktur ist verpflichtend. Ansonsten kann übergeben werden, wie viel Abstand der Baum im Editor auf der x-Achse zum linken Rand und auf der y-Achse zum oberen Rand haben soll. Standardmäßig werden 50 Pixel für die x-Achse und 25 Pixel für die y-Achse übergeben. Jedoch handelt es sich bei der Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} nur um eine Wrapperfunktion. Die eigentliche Umwandlung einer serialisierten Datenstruktur in einen \pfile{jsdot\_graph} geschieht in der Hilfsfunktion \textit{b\_tree\_initialize\_helper(...)}. Quellcode \ref{code:bTreeInitHelper} zeigt einen Ausschnitt der Hilfsfunktion.
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=Ausschnitt \textit{b\_tree\_initialize\_helper(...)}, frame=single, label=code:bTreeInitHelper]{code/bTreeInitHelper.php}
\end{figure}
Da es sich bei der serialisierten Datenstruktur um eine rekursiv aufgebaute Datenstruktur handelt ist die Verarbeitung dieser Struktur ebenfalls rekursiv aufgebaut. Der Hilfsfunktion wird eine serialisierte B-Baum-Datenstruktur übergeben. Wie in Kapitel \ref{sec:datenstruktur} beschrieben besteht die Datenstruktur einem Array, welches Schlüssel und Kindsknoten-Arrays des Wurzelknotens enthält. Auf Grund dieser Struktur wird jedes Element des Wurzelknoten-Arrays durchlaufen (Z. 4). Hierbei werden die einzelnen Knoten-Arrays des übergebenen B-Baums durch die Variable \pfile{\$json\_row} widergespiegelt. Für jedes Element in dem jeweiligen Array erfolgt eine Fallunterscheidung, in der geprüft wird, ob es sich bei dem jeweiligen Element um ein \textit{String} handelt. Ist das jeweilige Element ein \textit{String} (Z. 5), so muss es sich um einen Schlüssel im Array handeln. In diesem Fall wird ein neues \pfile{jsdot\_node} initialisiert und den Knoten des \pfile{\$jsdot\_graph} übergeben (Z. 6 f.). Es werden hierbei jeweils Name, Schlüssel und Position an den Knoten übergeben. Wie die Position bestimmt wird, wurde in Kapitel \ref{sec:positionierungElementeBBaum} erläutert. Handelt es sich nicht um einen \textit{String}, so muss es sich um ein Kindsknoten-Array handeln. In diesem Fall ruft die Hilfsfunktion sich selber auf, damit die Kindsknoten-Arrays auf die selbe Weise verarbeitet werden können. Quellcode \ref{code:rekursiverAufrufInitHelper} zeigt den rekursiven Aufruf in seiner Gesamtheit. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=rekursiver Aufruf aus Quellcode \ref{code:bTreeInitHelper} in Z. 10, frame=single, label=code:rekursiverAufrufInitHelper]{code/rekursiverAufrufInitHelper.php}
\end{figure}
Der erste übergebene Parameter ist wieder der in Funktion \textit{initialize\_with\_b\_tree\_data\_structure(...)} initialisierte \pfile{jsdot\_graph}. Der zweite Parameter ist das Kindsknoten-Array. Die nächsten beiden Parameter beschreiben die Position des Arrays. Als erstes wird die Höhe übergeben, die eine größer als die momentane Höhe ist. Danach wird die Position dieses Kindknotens innerhalb einer Schicht weitergegeben. \pfile{\$index\_node} sagt dabei aus, um den wievielten Kindsknoten es sich handelt. \pfile{\$index\_array} zeigt die Position des Wurzelknotens innerhalb der Schicht auf. Diese muss noch mit der maximale Verzweigung \pfile{\$t} multipliziert werden, damit die richtige Position für den Kindsknoten gefunden wird. Die Summe bildet schließlich die Finale Position. Die restlichen Parameter werden unverändert weitergegeben.
Zum Abbruch der Funktion dienen die kinderlosen Knoten, da in ihnen keine Kindsknoten-Arrays zum weiteren rekursiven Aufruf vorhanden sind.

Die Funktion \textit{get\_b\_tree\_data\_ structure(...)} wandelt wiederum eine \pfile{jsdot\_graph}-Datenstruktur in eine serialisierte Datenstruktur für den Webservice um. Quellcode \ref{code:getBTreeDataStructure} zeigt die gesamte Funktion. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=\textit{get\_b\_tree\_data\_ structure(...)}, frame=single, label=code:getBTreeDataStructure]{code/getBTreeDataStructure.php}
\end{figure}
So wird der \pfile{jsdot\_graph} als erstes in die Form \glqq Knoten pro Schicht\grqq \ umgewandelt (Z. 2). Da diese Form bereits aus Kapitel \ref{sec:positionierungElementeBBaum} bekannt ist, und die Umwandlung hier äquivalent verläuft, wird an dieser Stelle nicht weiter darauf eingegangen. Wichtig für diese Funktion ist jedoch noch, dass in ihr die Richtigkeit der Syntax des B-Baums geprüft wird. Es wird geprüft, ob alle Schlüssel Teil des Baums sind, ob alle Knoten die maximale Anzahl an Schlüsseln nicht überschreiten und ob der Baum ausbalanciert ist. Anschließend wird die rekursive Hilfsfunktion \textit{b\_tree\_structure\_helper(...)} aufgerufen, die die eigentliche Umwandlung umsetzt. Die Hilfsfunktion wird mit dem Wurzelknoten des B-Baums initialisiert (\pfile{\$nodesPerArray[0][0]}). Weiterhin wird noch der gesamte B-Baum, die Position des Wurzelknotens und die maximale Verzweigung \pfile{\$t} übergeben. Quellcode \ref{code:bTreeStructureHelper} zeigt die Hilfsfunktion. 
\begin{figure}[htbp] 
\lstinputlisting[language=PHP, caption=\textit{b\_tree\_structure\_helper(...)}, frame=single, label=code:bTreeStructureHelper]{code/bTreeStructureHelper.php}
\end{figure}
In der Funktion wird jeder Schlüssel des übergebenden Knotens (\pfile{\$nodeList}) durchlaufen (Z. 4). Für jedes Element wird zu erst geprüft, ob ein linker Kindsknoten existiert (Z. 5). Ist dies der Fall, ruft die Funktion sich selbst auf, wobei der Kindsknoten als zu bearbeitendes Element übergeben wird (Z. 6). Anschließend wird das Ergebnis dieses rekursiven Aufrufs zum Ergebnis hinzugefügt (Z. 7). Auch jeder Schlüssel wird dem Ergebnis übergeben (Z. 9). Die zweite if-Abfrage (Z. 10) prüft, ob es sich um den letzten Schlüssel eines Knotens handelt, und ob dieser einen rechten Kindsknoten hat. Ist dies der Fall, wird für diesen Kindsknoten ein weiterer rekursiver Aufruf initiiert (Z. 11). Als abbrechende Bedingung für die Rekursion dienen die Kinderlosen Knoten.

